# JavaScript引擎
JavaScript引擎是能够将JavaScript代码处理并执行的运行环境。
## JavaScript语言
* JavaScript是一种脚本语言，本质上是一种解释型语言
* JavaScript是一种弱类型语言，或者说动态类型语言，相较于Java等静态类型语言，Java在编译时候就知道变量的类型，而JavaScript需要在运行时才能确定，这导致JavaScript在运行时计算和决定类型(在代码的上下文中，可能会进行隐含的类型转换)会有性能损失

### JavaScript的作用域链和闭包
* **闭包** 闭包是一个拥有许多变量和绑定这些变量的环境的表达式(通常是一个函数), JavaScript使用作用域链来实现闭包，作用域由执行环境维护

## 组成结构
* **早期** 解释器解释即可,即源码 - 抽象语法树 - 解释执行
* **Java虚拟机的JIT技术引入** 源码 - 抽象语法树 - 中间表示(字节码) - 本地代码 - CPU直接执行
* **V8** 源码 - 抽象语法树 - 本地代码
![JavaScript与渲染引擎](images/javascript-compile.png)
* **编译器**
* **解释器**
* **JIT工具**
* **垃圾回收器和分析工具**
### JIT
解决解释性语言的性能问题，当解释器将源代码解释成为内部表示的时候，JavaScript的执行环境不仅是解释这些内部表示，而且将其中一些字节码(主要是使用率高的部分)转换成本地代码(汇编代码)，这样就可以被CPU直接执行，而不是解释执行，从而提高性能
## JavaScript引擎和渲染引擎
网页的工作过程需要两个引擎：渲染引擎和JavaScript引擎，那么它们是如何相互配合工作的呢
![JavaScript与渲染引擎](images/javascript-engine.png)
* JavaScript引擎负责执行JavaScript代码，提供调用接口给渲染引擎，以便让渲染引擎使用JavaScript引擎来执行JavaScript代码来获取结果
* JavaScript引擎需要访问渲染引擎构建的DOM树，所以需要提供桥接的接口，而渲染引擎根据桥接接口来提供让JavaScript引擎访问DOM的能力
* 在众多HTML5能力中，很多都是通过JavaScript接口提供给开发者的，渲染引擎实现具体接口提供给JavaScript引擎调用

## JavaScriptCore引擎

## V8引擎

### 数据表示
* **数据的实际内容** 
* **数据的句柄** 

### 工作过程
V8引擎编译本地代码时使用的主要类如下所示
* **Script** 表示JavaScript代码，即包含源代码，又包含编译之后生成的本地代码，即是编译入口，又是运行入口；
* **Compiler** 编译器类，辅组Script类来编译生成代码，调用解释器(Parser)来生成AST和全代码生成器，将AST转变为本地代码；
* **AstNode** 抽象语法树节点类，是其他所有节点的基类，包含非常多的子类，后面会针对不同的子类生成不同的本地代码；
* **AstVisitor** 抽象语法树的访问者类，主要用来遍历异构的抽象语法树；
* **FullCodeGenerator** AstVisitor类的子类，通过遍历AST来为JavaScript生成本地可执行代码。
　　JavaScript代码编译的过程大致为：Script类调用Compiler类的Compile函数为其生成本地代码。Compile函数先使用Parser类生成AST，再使用FullCodeGenerator类来生成本地代码。本地代码与具体的硬件平台密切相关，FullCodeGenerator使用多个后端来生成与平台相匹配的本地汇编代码。由于FullCodeGenerator通过遍历AST来为每个节点生成相应的汇编代码，缺失了全局视图，节点之间的优化也就无从谈起。

　　在执行编译之前，V8会构建众多全局对象并加载一些内置的库（如math库），来构建一个运行环境。而且在JavaScript源代码中，并非所有的函数都被编译生成本地代码，而是延迟编译，在调用时才会编译。

　　由于V8缺少了生成中间代码这一环节，缺少了必要的优化，为了提升性能，V8会在生成本地代码后，使用数据分析器(profiler)采集一些信息，然后根据这些数据将本地代码进行优化，生成更高效的本地代码，这是一个逐步改进的过程。同时，当发现优化后代码的性能还不如未优化的代码，V8将退回原来的代码，也就是优化回滚

### 内存管理
内存的管理组要由分配和回收两个部分构成。V8的内存划分主要在Zone类和堆中。
* **Zone** 管理小块内存。其先自己申请一块内存，然后管理和分配一些小内存，当一块小内存被分配之后，不能被Zone回收，只能一次性回收Zone分配的所有小内存。当一个过程需要很多内存，Zone将需要分配大量的内存，却又不能及时回收，会导致内存不足情况。
* **堆** 管理JavaScript使用的数据、生成的代码、哈希表等。为方便实现垃圾回收，堆被分为三个部分：
1. 年轻分代：为新创建的对象分配内存空间，经常需要进行垃圾回收。为方便年轻分代中的内容回收，可再将年轻分代分为两半，一半用来分配，另一半在回收时负责将之前还需要保留的对象复制过来。
2. 年老分代：根据需要将年老的对象、指针、代码等数据保存起来，较少地进行垃圾回收。
3. 大对象：为那些需要使用较多内存对象分配内存，当然同样可能包含数据和代码等分配的内存，一个页面只分配一个对象。

#### 内存回收
在V8中，使用较多的是年轻分代和年老分代。年轻分代中的对象垃圾回收主要通过Scavenge算法进行垃圾回收。在Scavenge的具体实现中，主要采用了Cheney算法：通过复制的方式实现的垃圾回收算法。它将堆内存分为两个 semispace，一个处于使用中（From空间），另一个处于闲置状态（To空间）。当分配对象时，先是在From空间中进行分配。当开始进行垃圾回收时，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间的角色发生对换。在垃圾回收的过程中，就是通过将存活对象在两个 semispace 空间之间进行复制。年轻分代中的对象有机会晋升为年老分代，条件主要有两个：一个是对象是否经历过Scavenge回收，一个是To空间的内存占用比超过限制。  
  
对于年老分代中的对象，由于存活对象占较大比重，再采用上面的方式会有两个问题：一个是存活对象较多，复制存活对象的效率将会很低；另一个问题依然是浪费一半空间的问题。为此，V8在年老分代中主要采用了Mark-Sweep（标记清除）标记清除和Mark-Compact（标记整理）相结合的方式进行垃圾回收。

### 功能扩展
* **绑定机制** 　使用IDL文件或接口文件生成绑定文件，将这些文件同V8引擎一起编译。WebKit中使用IDL来定义JavaScript，但又与IDL有所不同，有一些改变。  
JavaScript引擎绑定机制需要将扩展代码和JavaScript引擎一块编译和打包，不能根据需要在引擎启动后再动态注入这些本地代码。在实际WEB开发中，开发者都是基于现有浏览器的，根本不可能介入到JavaScript引擎的编译中，绑定机制有很大的局限性，但其非常高效，适用于对性能要求较高的场景。
* **Extension机制** 通过V8的基类Extension进行能力扩展，无需和V8引擎一起编译，可以动态为引擎增加功能特性，具有很大的灵活性。  
Extension机制是调用V8的接口注入新函数，动态扩展非常方便，但没有绑定机制高效，适用于对性能要求不高的场景。